// Code generated by protoc-gen-go. DO NOT EDIT.
// source: geo.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	geo.proto

It has these top-level messages:
	Address
	Point
	Device
	ResearchArea
	RouteSummary
	RouteNote
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Address struct {
	Address       string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	AddressNumber string `protobuf:"bytes,2,opt,name=addressNumber" json:"addressNumber,omitempty"`
	PostalCode    string `protobuf:"bytes,3,opt,name=postalCode" json:"postalCode,omitempty"`
	Place         string `protobuf:"bytes,4,opt,name=place" json:"place,omitempty"`
	Country       string `protobuf:"bytes,5,opt,name=country" json:"country,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto1.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Address) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Address) GetAddressNumber() string {
	if m != nil {
		return m.AddressNumber
	}
	return ""
}

func (m *Address) GetPostalCode() string {
	if m != nil {
		return m.PostalCode
	}
	return ""
}

func (m *Address) GetPlace() string {
	if m != nil {
		return m.Place
	}
	return ""
}

func (m *Address) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

type Point struct {
	Latitude  int32 `protobuf:"varint,1,opt,name=latitude" json:"latitude,omitempty"`
	Longitude int32 `protobuf:"varint,2,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto1.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Point) GetLatitude() int32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Point) GetLongitude() int32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

type Device struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (m *Device) String() string            { return proto1.CompactTextString(m) }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Device) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ResearchArea struct {
	Point     *Point `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Precision int32  `protobuf:"varint,2,opt,name=precision" json:"precision,omitempty"`
}

func (m *ResearchArea) Reset()                    { *m = ResearchArea{} }
func (m *ResearchArea) String() string            { return proto1.CompactTextString(m) }
func (*ResearchArea) ProtoMessage()               {}
func (*ResearchArea) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ResearchArea) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *ResearchArea) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// A RouteSummary is received in response to a RecordRoute rpc.
//
// It contains the number of individual points received,
// and the total distance covered as the cumulative sum of
// the distance between each point.
type RouteSummary struct {
	// The number of points received.
	PointCount int32 `protobuf:"varint,1,opt,name=point_count,json=pointCount" json:"point_count,omitempty"`
	// The distance covered in metres.
	Distance int32 `protobuf:"varint,3,opt,name=distance" json:"distance,omitempty"`
	// The duration of the traversal in seconds.
	ElapsedTime int32 `protobuf:"varint,4,opt,name=elapsed_time,json=elapsedTime" json:"elapsed_time,omitempty"`
}

func (m *RouteSummary) Reset()                    { *m = RouteSummary{} }
func (m *RouteSummary) String() string            { return proto1.CompactTextString(m) }
func (*RouteSummary) ProtoMessage()               {}
func (*RouteSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RouteSummary) GetPointCount() int32 {
	if m != nil {
		return m.PointCount
	}
	return 0
}

func (m *RouteSummary) GetDistance() int32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *RouteSummary) GetElapsedTime() int32 {
	if m != nil {
		return m.ElapsedTime
	}
	return 0
}

// A RouteNote is a message sent while at a given point.
type RouteNote struct {
	// The location of the other first responders
	Location *Point `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The message to be sent.
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *RouteNote) Reset()                    { *m = RouteNote{} }
func (m *RouteNote) String() string            { return proto1.CompactTextString(m) }
func (*RouteNote) ProtoMessage()               {}
func (*RouteNote) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RouteNote) GetLocation() *Point {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *RouteNote) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto1.RegisterType((*Address)(nil), "proto.Address")
	proto1.RegisterType((*Point)(nil), "proto.Point")
	proto1.RegisterType((*Device)(nil), "proto.Device")
	proto1.RegisterType((*ResearchArea)(nil), "proto.ResearchArea")
	proto1.RegisterType((*RouteSummary)(nil), "proto.RouteSummary")
	proto1.RegisterType((*RouteNote)(nil), "proto.RouteNote")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GeoService service

type GeoServiceClient interface {
	// Get an address and return a Point
	GetPoint(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Point, error)
	// A server-to-client streaming RPC.
	//
	// Obtains the Devices available within the given Precision.  Results are
	// streamed rather than returned at once (e.g. in a response message with a
	// repeated field), as the research area may cover a large area and contain a
	// huge number of devices.
	// Get a (Point and Precision) and return a stram of Nearest Device Tokens
	GetDeviceList(ctx context.Context, in *ResearchArea, opts ...grpc.CallOption) (GeoService_GetDeviceListClient, error)
	// A client-to-server streaming RPC.
	//
	// Accepts a stream of Points on a route being traversed, returning a
	// RouteSummary when traversal is completed.
	RecordRoute(ctx context.Context, opts ...grpc.CallOption) (GeoService_RecordRouteClient, error)
	// A Bidirectional streaming RPC.
	//
	// Accepts a stream of RouteNotes sent while a route is being traversed,
	// while receiving other RouteNotes (e.g. from other users).
	RouteChat(ctx context.Context, opts ...grpc.CallOption) (GeoService_RouteChatClient, error)
}

type geoServiceClient struct {
	cc *grpc.ClientConn
}

func NewGeoServiceClient(cc *grpc.ClientConn) GeoServiceClient {
	return &geoServiceClient{cc}
}

func (c *geoServiceClient) GetPoint(ctx context.Context, in *Address, opts ...grpc.CallOption) (*Point, error) {
	out := new(Point)
	err := grpc.Invoke(ctx, "/proto.GeoService/GetPoint", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) GetDeviceList(ctx context.Context, in *ResearchArea, opts ...grpc.CallOption) (GeoService_GetDeviceListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GeoService_serviceDesc.Streams[0], c.cc, "/proto.GeoService/GetDeviceList", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoServiceGetDeviceListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GeoService_GetDeviceListClient interface {
	Recv() (*Device, error)
	grpc.ClientStream
}

type geoServiceGetDeviceListClient struct {
	grpc.ClientStream
}

func (x *geoServiceGetDeviceListClient) Recv() (*Device, error) {
	m := new(Device)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geoServiceClient) RecordRoute(ctx context.Context, opts ...grpc.CallOption) (GeoService_RecordRouteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GeoService_serviceDesc.Streams[1], c.cc, "/proto.GeoService/RecordRoute", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoServiceRecordRouteClient{stream}
	return x, nil
}

type GeoService_RecordRouteClient interface {
	Send(*Point) error
	CloseAndRecv() (*RouteSummary, error)
	grpc.ClientStream
}

type geoServiceRecordRouteClient struct {
	grpc.ClientStream
}

func (x *geoServiceRecordRouteClient) Send(m *Point) error {
	return x.ClientStream.SendMsg(m)
}

func (x *geoServiceRecordRouteClient) CloseAndRecv() (*RouteSummary, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RouteSummary)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *geoServiceClient) RouteChat(ctx context.Context, opts ...grpc.CallOption) (GeoService_RouteChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GeoService_serviceDesc.Streams[2], c.cc, "/proto.GeoService/RouteChat", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoServiceRouteChatClient{stream}
	return x, nil
}

type GeoService_RouteChatClient interface {
	Send(*RouteNote) error
	Recv() (*RouteNote, error)
	grpc.ClientStream
}

type geoServiceRouteChatClient struct {
	grpc.ClientStream
}

func (x *geoServiceRouteChatClient) Send(m *RouteNote) error {
	return x.ClientStream.SendMsg(m)
}

func (x *geoServiceRouteChatClient) Recv() (*RouteNote, error) {
	m := new(RouteNote)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GeoService service

type GeoServiceServer interface {
	// Get an address and return a Point
	GetPoint(context.Context, *Address) (*Point, error)
	// A server-to-client streaming RPC.
	//
	// Obtains the Devices available within the given Precision.  Results are
	// streamed rather than returned at once (e.g. in a response message with a
	// repeated field), as the research area may cover a large area and contain a
	// huge number of devices.
	// Get a (Point and Precision) and return a stram of Nearest Device Tokens
	GetDeviceList(*ResearchArea, GeoService_GetDeviceListServer) error
	// A client-to-server streaming RPC.
	//
	// Accepts a stream of Points on a route being traversed, returning a
	// RouteSummary when traversal is completed.
	RecordRoute(GeoService_RecordRouteServer) error
	// A Bidirectional streaming RPC.
	//
	// Accepts a stream of RouteNotes sent while a route is being traversed,
	// while receiving other RouteNotes (e.g. from other users).
	RouteChat(GeoService_RouteChatServer) error
}

func RegisterGeoServiceServer(s *grpc.Server, srv GeoServiceServer) {
	s.RegisterService(&_GeoService_serviceDesc, srv)
}

func _GeoService_GetPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).GetPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.GeoService/GetPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).GetPoint(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_GetDeviceList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResearchArea)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoServiceServer).GetDeviceList(m, &geoServiceGetDeviceListServer{stream})
}

type GeoService_GetDeviceListServer interface {
	Send(*Device) error
	grpc.ServerStream
}

type geoServiceGetDeviceListServer struct {
	grpc.ServerStream
}

func (x *geoServiceGetDeviceListServer) Send(m *Device) error {
	return x.ServerStream.SendMsg(m)
}

func _GeoService_RecordRoute_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GeoServiceServer).RecordRoute(&geoServiceRecordRouteServer{stream})
}

type GeoService_RecordRouteServer interface {
	SendAndClose(*RouteSummary) error
	Recv() (*Point, error)
	grpc.ServerStream
}

type geoServiceRecordRouteServer struct {
	grpc.ServerStream
}

func (x *geoServiceRecordRouteServer) SendAndClose(m *RouteSummary) error {
	return x.ServerStream.SendMsg(m)
}

func (x *geoServiceRecordRouteServer) Recv() (*Point, error) {
	m := new(Point)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GeoService_RouteChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GeoServiceServer).RouteChat(&geoServiceRouteChatServer{stream})
}

type GeoService_RouteChatServer interface {
	Send(*RouteNote) error
	Recv() (*RouteNote, error)
	grpc.ServerStream
}

type geoServiceRouteChatServer struct {
	grpc.ServerStream
}

func (x *geoServiceRouteChatServer) Send(m *RouteNote) error {
	return x.ServerStream.SendMsg(m)
}

func (x *geoServiceRouteChatServer) Recv() (*RouteNote, error) {
	m := new(RouteNote)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GeoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.GeoService",
	HandlerType: (*GeoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPoint",
			Handler:    _GeoService_GetPoint_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDeviceList",
			Handler:       _GeoService_GetDeviceList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecordRoute",
			Handler:       _GeoService_RecordRoute_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RouteChat",
			Handler:       _GeoService_RouteChat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "geo.proto",
}

func init() { proto1.RegisterFile("geo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 427 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x8d, 0x0b, 0x6e, 0x93, 0x49, 0x82, 0xd0, 0xc0, 0xc1, 0xb2, 0x50, 0x81, 0x15, 0x87, 0x88,
	0x43, 0x55, 0x15, 0x10, 0xe7, 0x28, 0x48, 0xb9, 0xa0, 0x52, 0xb9, 0xdc, 0xab, 0xed, 0x7a, 0x94,
	0xae, 0xb0, 0xbd, 0xd6, 0xee, 0x1a, 0xa9, 0x9f, 0xc2, 0xcf, 0xf1, 0x2d, 0x68, 0x67, 0x37, 0x26,
	0x11, 0x9c, 0xbc, 0xef, 0xcd, 0xec, 0xbc, 0x79, 0x6f, 0x0d, 0xb3, 0x1d, 0x99, 0x8b, 0xde, 0x1a,
	0x6f, 0x30, 0xe7, 0x8f, 0xf8, 0x95, 0xc1, 0xd9, 0xba, 0xae, 0x2d, 0x39, 0x87, 0x05, 0x9c, 0xc9,
	0x78, 0x2c, 0xb2, 0x37, 0xd9, 0x6a, 0x56, 0xed, 0x21, 0xbe, 0x83, 0x65, 0x3a, 0x5e, 0x0f, 0xed,
	0x3d, 0xd9, 0xe2, 0x84, 0xeb, 0xc7, 0x24, 0x9e, 0x03, 0xf4, 0xc6, 0x79, 0xd9, 0x6c, 0x4c, 0x4d,
	0xc5, 0x13, 0x6e, 0x39, 0x60, 0xf0, 0x25, 0xe4, 0x7d, 0x23, 0x15, 0x15, 0x4f, 0xb9, 0x14, 0x41,
	0x50, 0x55, 0x66, 0xe8, 0xbc, 0x7d, 0x2c, 0xf2, 0xa8, 0x9a, 0xa0, 0x58, 0x43, 0x7e, 0x63, 0x74,
	0xe7, 0xb1, 0x84, 0x69, 0x23, 0xbd, 0xf6, 0x43, 0x4d, 0xbc, 0x59, 0x5e, 0x8d, 0x18, 0x5f, 0xc1,
	0xac, 0x31, 0xdd, 0x2e, 0x16, 0x4f, 0xb8, 0xf8, 0x97, 0x10, 0xe7, 0x70, 0xfa, 0x85, 0x7e, 0x6a,
	0xc5, 0xe2, 0xde, 0xfc, 0xa0, 0x2e, 0x59, 0x8b, 0x40, 0xdc, 0xc0, 0xa2, 0x22, 0x47, 0xd2, 0xaa,
	0x87, 0xb5, 0x25, 0x89, 0x02, 0xf2, 0x3e, 0x48, 0x72, 0xd7, 0xfc, 0x6a, 0x11, 0xc3, 0xba, 0xe0,
	0x35, 0xaa, 0x58, 0x0a, 0x8a, 0xbd, 0x25, 0xa5, 0x9d, 0x36, 0xdd, 0x5e, 0x71, 0x24, 0x44, 0x07,
	0x8b, 0xca, 0x0c, 0x9e, 0x6e, 0x87, 0xb6, 0x95, 0xf6, 0x11, 0x5f, 0xc3, 0x9c, 0xaf, 0xdd, 0xb1,
	0xab, 0xb4, 0x3e, 0x30, 0xb5, 0x09, 0x4c, 0x30, 0x57, 0x6b, 0xe7, 0x65, 0xa7, 0x62, 0x66, 0x79,
	0x35, 0x62, 0x7c, 0x0b, 0x0b, 0x6a, 0x64, 0xef, 0xa8, 0xbe, 0xf3, 0xba, 0x8d, 0xc1, 0xe5, 0xd5,
	0x3c, 0x71, 0xdf, 0x75, 0x4b, 0xe2, 0x1b, 0xcc, 0x58, 0xef, 0xda, 0x78, 0xc2, 0x15, 0x4c, 0x1b,
	0xa3, 0xa4, 0x0f, 0x9b, 0xfd, 0xcf, 0xc1, 0x58, 0x0d, 0xa9, 0xb7, 0xe4, 0x9c, 0xdc, 0x51, 0x7a,
	0xcb, 0x3d, 0xbc, 0xfa, 0x9d, 0x01, 0x6c, 0xc9, 0xdc, 0x92, 0xe5, 0xdc, 0xde, 0xc3, 0x74, 0x4b,
	0x3e, 0xbe, 0xc3, 0xb3, 0x34, 0x2c, 0xfd, 0x30, 0xe5, 0xd1, 0x70, 0x31, 0xc1, 0xcf, 0xb0, 0xdc,
	0x92, 0x8f, 0x81, 0x7f, 0xd5, 0xce, 0xe3, 0x8b, 0xd4, 0x70, 0x98, 0x71, 0xb9, 0x4c, 0x64, 0xec,
	0x13, 0x93, 0xcb, 0x0c, 0x3f, 0xc2, 0xbc, 0x22, 0x65, 0x6c, 0xcd, 0x56, 0xf0, 0x68, 0x6e, 0x39,
	0x0e, 0x39, 0x88, 0x55, 0x4c, 0x56, 0x19, 0x7e, 0x4a, 0xd6, 0x37, 0x0f, 0xd2, 0xe3, 0xf3, 0xc3,
	0xae, 0x10, 0x46, 0xf9, 0x0f, 0x13, 0x2e, 0x5d, 0x66, 0xf7, 0xa7, 0x4c, 0x7f, 0xf8, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x28, 0x39, 0x59, 0x73, 0x0d, 0x03, 0x00, 0x00,
}
